{"version":3,"file":"utils.js","sources":["uni_modules/v-tabs/components/v-tabs/utils.js"],"sourcesContent":["/**\n * 启动一个微任务。\n *\n * 该函数旨在兼容不同环境下的微任务调度。微任务是一种在主任务（如事件循环中的回调）之后，但在下一次渲染之前执行的JavaScript任务。\n * 它们对于异步编程和性能优化非常重要。此函数尝试使用三种不同的方法来调度微任务，取决于环境的支持情况。\n *\n * @param {Function} callback - 待执行的微任务回调函数。\n */\nexport function startMicroTask(callback) {\n  // 如果队列微任务是可用的，直接使用队列微任务的方法来调度回调。\n  if (typeof queueMicrotask === 'function') {\n    queueMicrotask(callback)\n  } else if (typeof MutationObserver === 'function') {\n    // 如果MutationObserver可用，使用它来创建一个微任务。\n    // 这是一种旧的兼容性方法，因为MutationObserver在较早的浏览器版本中就已经支持。\n    const node = document.createElement('div')\n    const observer = new MutationObserver(callback)\n    observer.observe(node, { childList: true })\n    node.textContent = 'xfjpeter'\n  } else {\n    // 如果以上两种方法都不可用，退回到使用setTimeout来模拟微任务。\n    // 这是最后的选择，因为setTimeout不是真正的微任务，但它可以在不支持微任务的环境中提供类似的功能。\n    setTimeout(callback, 0)\n  }\n}\n\n/**\n * 函数节流器。\n * 通过限制函数调用的频率，防止在高频率事件（如窗口滚动或鼠标移动）中过多调用给定的函数，从而优化性能。\n *\n * @param {Function} fn 要节流的函数。\n * @param {number} delay 延迟的毫秒数，在这段时间内只能调用一次给定的函数。\n * @returns {Function} 返回一个新的节流函数，它将控制原始函数的调用频率。\n */\n/**\n * 函数节流器\n * @param {Function} fn 要节流的函数\n * @param {number} delay 延迟的毫秒数\n * @returns {Function} 返回节流后的函数\n */\nexport function throttle(fn, delay) {\n  // 用于存储定时器ID\n  let timeoutId\n  // 用于记录上一次函数执行的时间\n  let lastExecuted = 0\n\n  // 返回一个节流函数\n  return function () {\n    // 保存当前上下文和参数\n    const context = this\n    const args = arguments\n    // 获取当前时间\n    const now = Date.now()\n    // 计算剩余时间\n    const remaining = delay - (now - lastExecuted)\n\n    // 实际执行函数的内部函数\n    function execute() {\n      lastExecuted = now\n      // 在当前上下文中调用原始函数，并传入参数\n      fn.apply(context, args)\n    }\n\n    // 如果剩余时间小于等于0，表示可以执行函数\n    if (remaining <= 0) {\n      // 如果存在定时器，则清除定时器\n      if (timeoutId) {\n        clearTimeout(timeoutId)\n        timeoutId = null\n      }\n      // 执行函数\n      execute()\n    } else {\n      // 如果不存在定时器，则设置定时器\n      if (!timeoutId) {\n        timeoutId = setTimeout(() => {\n          timeoutId = null\n          // 执行函数\n          execute()\n        }, remaining)\n      }\n    }\n  }\n}\n\n/**\n * 函数防抖动封装。\n * 函数防抖（debounce）是指在事件被触发n秒后，才执行回调，如果在这n秒内事件又被触发，则重新计时。\n * 主要用于限制函数调用的频率，常用于输入事件处理函数（如输入框的keyup事件）和窗口大小调整事件等。\n *\n * @param {Function} fn 需要被延迟执行的函数。\n * @param {number} delay 延迟执行的时间，单位为毫秒。\n * @returns {Function} 返回一个经过防抖动处理的函数。\n */\nexport function debounce(fn, delay) {\n  // 用于存储定时器的变量\n  let timer = null\n\n  // 返回一个封装函数\n  return function () {\n    // 如果定时器存在，则清除之前的定时器\n    if (timer) clearTimeout(timer)\n\n    // 设置新的定时器，延迟执行原函数\n    timer = setTimeout(() => {\n      // 使用apply确保函数在正确的上下文中执行，并传递所有参数\n      fn.apply(this, arguments)\n    }, delay)\n  }\n}\n"],"names":[],"mappings":";AAQO,SAAS,eAAe,UAAU;AAEvC,MAAI,OAAO,mBAAmB,YAAY;AACxC,mBAAe,QAAQ;AAAA,EAC3B,WAAa,OAAO,qBAAqB,YAAY;AAGjD,UAAM,OAAO,SAAS,cAAc,KAAK;AACzC,UAAM,WAAW,IAAI,iBAAiB,QAAQ;AAC9C,aAAS,QAAQ,MAAM,EAAE,WAAW,KAAI,CAAE;AAC1C,SAAK,cAAc;AAAA,EACvB,OAAS;AAGL,eAAW,UAAU,CAAC;AAAA,EACvB;AACH;AAgBO,SAAS,SAAS,IAAI,OAAO;AAElC,MAAI;AAEJ,MAAI,eAAe;AAGnB,SAAO,WAAY;AAEjB,UAAM,UAAU;AAChB,UAAM,OAAO;AAEb,UAAM,MAAM,KAAK,IAAK;AAEtB,UAAM,YAAY,SAAS,MAAM;AAGjC,aAAS,UAAU;AACjB,qBAAe;AAEf,SAAG,MAAM,SAAS,IAAI;AAAA,IACvB;AAGD,QAAI,aAAa,GAAG;AAElB,UAAI,WAAW;AACb,qBAAa,SAAS;AACtB,oBAAY;AAAA,MACb;AAED,cAAS;AAAA,IACf,OAAW;AAEL,UAAI,CAAC,WAAW;AACd,oBAAY,WAAW,MAAM;AAC3B,sBAAY;AAEZ,kBAAS;AAAA,QACV,GAAE,SAAS;AAAA,MACb;AAAA,IACF;AAAA,EACF;AACH;;;"}